import timefrom paho.mqtt import client as mqtt_client# host infobroker = 'qb5ddeee.us-east-1.emqx.cloud'port = 15490# authenticationsclient_id = '3310-6828533-0'username = 'student'password = '33102021'# dynamic variablesqos_dynamic = 0delay_dynamic = 0# message counter and timermsg_count = 0timestamp = time.time()# Reference: https://www.emqx.io/blog/how-to-use-mqtt-in-pythondef connect_mqtt():    print("")    print("Publisher -> Connecting to MQTT Broker (づ￣ ³￣)づ ")    # The callback for when the client receives a CONNACK response from the server.    def on_connect(client, userdata, flags, rc):        if rc == 0:            client.subscribe('request/qos')            client.subscribe('request/delay')        else:            print(f"Failed to connect, return code {rc} (╯°□°）╯︵ ┻━┻ ")    # The callback for when a PUBLISH message is received from the server.    def on_message(client, userdata, msg):        global qos_dynamic, delay_dynamic        # subscribe to topics 'request/qos' and 'request/delay'        if msg.topic == 'request/qos':            qos_dynamic = int(msg.payload)        elif msg.topic == 'request/delay':            delay_dynamic = int(msg.payload)    client = mqtt_client.Client(client_id, clean_session=True, protocol=mqtt_client.MQTTv311, transport='tcp')    client.username_pw_set(username, password)    client.on_connect = on_connect    client.on_message = on_message    client.connect(broker, port)    return client# publish to topic 'counter/qos/delay'def publish(client):    global msg_count, timestamp    time4sleep = timestamp - time.time() + delay_dynamic / 1000    if time4sleep >= 0:        time.sleep(time4sleep)    timestamp = time.time()    client.publish(f'counter/{qos_dynamic}/{delay_dynamic}', payload=f'{msg_count}', qos=qos_dynamic)    # print(f'Published message: counter/{qos_dynamic}/{delay_dynamic} -> {msg_count}')    msg_count += 1def run():    client = connect_mqtt()    client.loop_start()    while True:        publish(client)if __name__ == '__main__':    run()