import csvimport itertoolsimport sysimport timeimport numpy as npfrom paho.mqtt import client as mqtt_client, publish as mqtt_publish# data collecting durationcollecting_time = 120# host infobroker = 'qb5ddeee.us-east-1.emqx.cloud'port = 15490# authenticationsclient_id = '3310-6828533-1'username = 'student'password = '33102021'# specific rangesqos_levels = [0, 1, 2]delays = [0, 10, 20, 50, 100, 500]# statistics collectionid_collection, timestamp_collection = [], []# analytic metricsavg_list, loss_list, ooo_list, mean_gap_list, median_gap_list = [], [], [], [], []# Reference: https://www.emqx.io/blog/how-to-use-mqtt-in-pythondef connect_mqtt():    print("Analyser  -> Connecting to MQTT Broker (づ￣ ³￣)づ ")    print("Please wait for data collection process ♪~ ᕕ(ᐛ)ᕗ ")    print("")    # The callback for when the client receives a CONNACK response from the server.    def on_connect(client, userdata, flags, rc):        if rc == 0:            for q, d in itertools.product(qos_levels, delays):                # subscribe to 18 topics in total, subscribe at the same QoS as requested                client.subscribe(f'counter/{q}/{d}', qos=q)        else:            print(f"Failed to connect, return code {rc} (╯°□°）╯︵ ┻━┻ ")    # The callback for when a PUBLISH message is received from the server.    def on_message(client, userdata, msg):        global id_collection, timestamp_collection        id_collection.append(int(msg.payload))        timestamp_collection.append(time.time())    client = mqtt_client.Client(client_id, clean_session=True, protocol=mqtt_client.MQTTv311, transport='tcp')    client.username_pw_set(username, password)    client.on_connect = on_connect    client.on_message = on_message    client.connect(broker, port)    return client# collect sampling data for a specific durationdef sampling(qos, delay):    global id_collection, timestamp_collection    # publish to topics 'request/qos' and 'request/delay'    msgs = [{'topic': 'request/qos', 'payload': str(qos)},            {'topic': 'request/delay', 'payload': str(delay)}]    mqtt_publish.multiple(msgs, hostname=broker, port=port,                          client_id=client_id, auth={'username': username, 'password': password},                          protocol=mqtt_client.MQTTv311, transport='tcp')    time.sleep(collecting_time)    data_analysis(id_collection, timestamp_collection, collecting_time, qos, delay)    id_collection, timestamp_collection = [], []# calculate the metrics and generate a csv filedef data_analysis(packet_ids, timestamps, duration, qos, delay):    global avg_list, loss_list, ooo_list, mean_gap_list, median_gap_list    total_packets = len(packet_ids)    if total_packets != 0:        # average rate        mean_rate = round(total_packets / duration, 1)        # loss rate        expected = np.ptp(packet_ids) + 1        received = total_packets        loss_rate = round((1 - received / expected) * 100, 1)        # out of order rate        ooo_count = 0        p0 = -sys.maxsize        for p in packet_ids:            if p < p0:                ooo_count += 1            else:                p0 = p        ooo_rate = round((ooo_count / total_packets) * 100, 1)        # mean & median inter-message-gap (img)        consecutive_gaps = [timestamps[i] - timestamps[i - 1] for i in range(1, total_packets) if                            packet_ids[i] - packet_ids[i - 1] == 1]        if consecutive_gaps:            mean_gap = round((np.mean(consecutive_gaps) * 1000), 1)            median_gap = round((np.median(consecutive_gaps) * 1000), 1)        else:            mean_gap, median_gap = 0, 0    else:        mean_rate, loss_rate, ooo_rate, mean_gap, median_gap = 0, 0, 0, 0, 0    avg_list.append(mean_rate)    loss_list.append(loss_rate)    ooo_list.append(ooo_rate)    mean_gap_list.append(mean_gap)    median_gap_list.append(median_gap)    print(f"----------- counter/{qos}/{delay} -----------")    print("")    print(f"average_rate = {mean_rate} messages/s")    print(f"loss_rate = {loss_rate} %")    print(f"out_of_order_rate = {ooo_rate} %")    print(f"mean_inter_message_gap = {mean_gap} ms")    print(f"median_inter_message_gap = {median_gap} ms")    print("")    print("")def run():    client = connect_mqtt()    client.loop_start()    for q, d in itertools.product(qos_levels, delays):        sampling(q, d)    client.loop_stop()    print("")    print(" ~(˘▾˘~) Data collection finished (~˘▾˘)~ ")    print("Statistics are there for you in stats.csv")    header = ['avg_rate', 'loss_rate', 'out_of_order_rate', 'mean_inter_message_gap', 'median_inter_message_gap']    data = [        [avg_list[i], loss_list[i], ooo_list[i], mean_gap_list[i], median_gap_list[i]]        for i in range(len(avg_list))    ]    # Reference: https://www.pythontutorial.net/python-basics/python-write-csv-file/    with open('stats.csv', 'w', encoding='UTF8', newline='') as f:        writer = csv.writer(f)        # write the header        writer.writerow(header)        # write multiple rows        writer.writerows(data)if __name__ == '__main__':    run()